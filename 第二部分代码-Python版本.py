import sys

def trunc(x):
    return x if x > 0 else 0

#为已知变量赋初值
nDays = 60
s = 480
c = 8
ic = 20
sumd = [0 for i in range(65)]
f = [[sys.maxsize for j in range(2000)]for i in range(nDays)]
trace = [[0 for j in range(2000)]for i in range(nDays)]

#设计三组测试数据
p1 = [20.0,19.0,21.0,20.0,19.0,21.0,21.0,19.0,20.0,18.0,21.0,21.0,21.0,18.0,20.0,20.0,20.0,20.0,
      21.0,18.0,20.0,19.0,20.0,21.0,21.0,20.0,21.0,18.0,20.0,21.0,20.0,20.0,21.0,21.0,21.0,20.0,
      20.0,20.0,21.0,22.0,20.0,19.0,20.0,18.0,20.0,19.0,20.0,20.0,21.0,20.0,21.0,19.0,19.0,20.0,
      19.0,20.0,20.0,20.0,21.0,22.0]
d1 = [9,3,0,0,0,0,2,0,0,0,2,2,3,0,1,3,4,4,7,1,5,4,6,8,10,7,9,5,9,12,9,11,13,14,14,12,13,13,16,19,
      15,14,16,12,17,16,18,19,21,20,22,18,18,21,21,22,24,23,25,28]
p2 = [41.0,42.0,43.0,45.0,48.0,49.0,40.0,49.0,48.0,47.0,46.0,45.0,44.0,48.0,20.0,20.0,20.0,100.0,
      100.0,118.0,120.0,119.0,20.0,21.0,21.0,20.0,121.0,118.0,30.0,55.0,60.0,56.0,71.0,61.0,51.0,
      50.0,120.0,120.0,121.0,122.0,120.0,119.0,70.0,78.0,70.0,79.0,60.0,60.0,61.0,60.0,61.0,59.0,
      79.0,60.0,79.0,40.0,80.0,60.0,51.0,52.0]
d2 = [9,3,0,0,0,0,2,0,0,0,2,2,3,0,1,3,4,4,7,1,5,4,6,8,10,7,9,5,9,12,9,11,13,14,14,12,13,13,16,19,
      15,100,16,12,17,16,18,19,21,20,100,18,18,21,21,22,24,23,25,28]
p3 = [1.0,2.0,3.0,5.0,48.0,49.0,40.0,49.0,48.0,47.0,46.0,45.0,44.0,48.0,20.0,20.0,20.0,100.0,100.0,
    118.0,120.0,119.0,20.0,21.0,21.0,20.0,121.0,118.0,30.0,55.0,60.0,56.0,71.0,61.0,51.0,50.0,
    120.0,120.0,121.0,122.0,120.0,119.0,70.0,78.0,70.0,79.0,60.0,60.0,61.0,60.0,61.0,59.0,79.0,
    60.0,79.0,40.0,80.0,60.0,51.0,52.0]
d3 = [9,3,0,0,0,0,2,0,0,0,2,2,3,0,1,3,4,4,7,1,5,4,6,8,0,7,9,5,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
     0,1000,0,0,0,0,0,0,0,0,0,0,11]

#以第一组测试数据为例
p = p1
d = d1

#生成最小成本和订货策略
def min_cost_plan():
    #计算订货区间内总订货量
    sumd[0] = d[0]
    for i in range(1, nDays):
        sumd[i] = sumd[i - 1] + d[i]
    
    #为第一天的初始订货状态赋初值 
    for j in range(2000):
        ifBuy = 1 if j >0 else 0
        f[0][j] = ifBuy * s + j * p[0] + trunc(sumd[0] - j) * ic +(j + trunc(j - sumd[0])) * 0.5 * c
    
    #利用第一天的订货状态逐日更新往后每一天的最优策略，同时记录当前最优策略是由哪一种状态更新而来的 
    for i in range(1, nDays):
        for j in range(0, 2000):
            for k in range(0, j+1):
                ifBuy = 1 if j>k else 0
                cost = ifBuy * s + (j - k) * p[i] + trunc(sumd[i] - j) * ic + (trunc(k - sumd[i - 1]) + j - k + trunc(j - sumd[i])) * 0.5 * c
                totalcost = f[i - 1][k] + cost
                if totalcost < f[i][j]:
                    f[i][j] = totalcost
                    trace[i][j] = k
    
    #寻找出成本最低的总订货量
    minCost = sys.maxsize
    for j in range(sumd[50],2000):
        if f[59][j] < minCost:
            minCost = f[59][j]
            lk = j
    
    #利用最后一天的最优策略以及之前记录的状态更新过程，倒推出60天内每一天的订货策略
    seq= [0 for i in range(65)]
    for j in range(59,-1,-1):
        lastk = trace[j][lk]
        seq[j] = lk - lastk
        lk = lastk
    return(minCost,seq)

#输出测试结果
mincost,seqans = min_cost_plan()
print('最小成本为：',mincost)
print('最小成本订货方案为：',seqans)